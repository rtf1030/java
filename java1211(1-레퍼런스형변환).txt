
public class Ex {

	public static void main(String[] args) {
		/*
		 * 레퍼런스 형변환
		 * - 참조형(레퍼런스타입) 끼리의 형변환
		 * - 참조형 변수를 사용하여 다른 타입의 인스턴스(객체)를 참조하기 위해 변환하는 것
		 * - 업캐스팅(Up casting)과 다운캐스팅(Down casting) 으로 분류됨
		 * 
		 * 1. 업캐스팅(Up casting)
		 * - 슈퍼클래스의 레퍼런스가 서브클래스의 인스턴스를 참조하는 것(가리키는 것)
		 *   = 서브클래스의 인스턴스를 슈퍼클래스 타입으로 변환하는 것
		 * - 묵시적 형변환(자동 형변환)이 일어남
		 * - 참조 가능 영역에 대한 축소 발생
		 *   => 슈퍼클래스로부터 상속된 멤버만 접근 가능하고, 서브클래스의 멤버는 접근 불가
		 * - 일반적인 클래스간의 형변환은 대부분 업캐스팅을 의미함
		 * - 업캐스팅을 통해 다형성(Polymorphism) 활용이 가능
		 * 
		 * 2. 다운캐스팅(Down casting)
		 * - 서브클래스의 레퍼런스가 슈퍼클래스의 인스턴스를 참조하는 것(가리키는 것)
		 *   = 슈퍼클래스의 인스턴스를 서브클래스 타입으로 변환하는 것
		 * - 참조 가능한 영역에 대한 확대 발생
		 * - 자동 형변환이 일어나지 않으므로, 명시적(강제) 형변환이 필수!
		 *   => 즉, 형변환 연산자를 통해 좌변(서브클래스)의 데이터타입을 명시해야한다!
		 * - 명시적 형변환을 통해 문법적(구문) 오류가 해결되더라도
		 *   실제 실행 시점에서 오류가 발생하게 됨
		 *   => 참조 가능 영역의 확대로 인해 존재하지 않는 영역에 대한 참조의 위험성 때문
		 */
		
		// 기본데이터타입에서의 자동 형변환
//		int a = 10;
//		long l = a; // int(작은타입) -> long(큰타입) 변환 시 자동 형변환 일어남
		// => 오버플로우(넘침)가 발생할 우려가 없으므로 안전하기 때문에 자동 형변환 가능
		// => 물론, 강제형변환을 위해 형변환 연산자를 사용해도 아무런 문제가 없으며
		//    기본적으로 자동 형변환이므로 형변환 연산자를 생략하고 사용
//		long l = (long)a; // 명시적 형변환도 가능하며, 형변환 연산자 생략 가능
//		System.out.println("a = " + a + ", l = " + l);
		// -------------------------------------------------------------------
		// 1. 참조데이터타입에서의 묵시적(자동) 형변환 = 업캐스팅
		// -------------------------------------------------------------------
		// 서브클래스타입 Child 의 인스턴스 생성
		Child c = new Child();
		// Child 타입 참조변수로 접근 가능한 메서드 : 2개
		c.parentPrn(); // 슈퍼클래스 부모(Parent)로부터 상속받은 메서드
		c.childPrn(); // 서브클래스 자신(Child)이 직접 정의한 메서드
		
		// 슈퍼클래스타입 레퍼런스 변수 선언
		Parent p;
		p = c; // 서브클래스 인스턴스 주소를 슈퍼클래스 타입 변수에 전달
		// = 슈퍼클래스타입 변수(p)가 서브클래스 인스턴스(c)를 가리킴
		// => 이 때, 자동으로 Child -> Parent 변환이 일어나므로 업캐스팅

		// 슈퍼클래스타입 참조변수로 접근 가능한 메서드 : 1개
		p.parentPrn(); // 슈퍼클래스 부모(Parent)로부터 상속받은 메서드
//		p.childPrn(); // 컴파일에러 발생! 서브클래스에서 정의한 메서드는 접근 불가능!
		// => 업캐스팅 후에는 참조 영역에 대한 축소(제한)로 인해
		//    서브클래스의 멤버가 더 이상 보이지 않는다!
		//    즉, 슈퍼클래스에 정의된 공통 멤버에만 접근이 가능하도록 접근 범위가 변경됨
		
		System.out.println("==================================================");
		// -------------------------------------------------------------------
		// 2. 참조데이터타입에서의 명시적(강제) 형변환 = 다운캐스팅
		// -------------------------------------------------------------------
		// 슈퍼클래스 타입 Parent 인스턴스 생성
		Parent p2 = new Parent();
		// 슈퍼클래스 타입 Parent 변수 p2 로 접근 가능한 메서드 : 1개
		p2.parentPrn();
		
		// 서브클래스 타입 레퍼런스 변수(c2) 선언
		Child c2;
		// 서브클래스 타입 레퍼런스 변수(c2)에 슈퍼클래스 인스턴스 주소(p2) 전달
//		c2 = p2; // 컴파일에러 발생! 컴파일러에 의한 자동 형변환이 제공되지 않는다!
		// => Type mismatch: cannot convert from Parent to Child
		//    따라서, Parent -> Child 타입으로 변환 시 명시적 형변환이 필수!
//		c2 = (Child)p2; // 컴파일 에러는 발생하지 않지만, 실행 시점에서 논리적 오류 발생!
		// => Parent cannot be cast to Child (Parent 를 Child 로 변환할 수 없다!)
		
		// 만약, 변환이 가능했다고 가정했을 때
		// 서브클래스 타입 레퍼런스 변수(c2)로 접근 가능한 메서드 : 2개
//		c.parentPrn(); // 실제 Parent 인스턴스에 존재하는 메서드
//		c.childPrn(); // 실제 Parent 인스턴스에 "존재하지 않는" 메서드
		// => 주의! childPrn() 메서드는 실제 Parent 인스턴스에는 존재하지 않는 메서드이며
		//    Child 클래스가 이 메서드를 갖고 있으므로 컴파일 시점에서는 참조 가능한 메서드
		//    따라서, 다운캐스팅 후에는 존재하지 않는 영역에 대한 참조 위험성이 발생하므로
		//    자바에서는 대부분의 다운캐스팅은 인정하지 않는다! = 실행 시 오류 발생!
		System.out.println("==================================================");
		// -------------------------------------------------------------------
		// 3. 다운캐스팅이 가능한 경우
		// => 이전에 이미 업캐스팅 된 인스턴스를 다시 다운캐스팅 하는 경우
		// -------------------------------------------------------------------
		// Child 타입 인스턴스를 Parent 타입 변수 p3 에 전달
//		Parent p3; // 슈퍼클래스타입 레퍼런스 변수 p3 선언
//		p3 = new Child(); // 서브클래스 인스턴스를 슈퍼클래스타입 변수에 전달
		// 위의 두 문장을 한 문장으로 결합
		Parent p3 = new Child(); // Child -> Parent 로 업캐스팅(자동 형변환)
		// 업캐스팅 후에는 참조 가능 영역에 대한 축소가 발생함
		// 슈퍼클래스(Parent) 타입 변수 p3 로 접근 가능한 메서드 : 1개
		p3.parentPrn(); // 상속된 메서드(공통 영역) 접근 가능
//		p3.childPrn(); // 상속되지 않은(Parent 에 정의되어 있지 않은) 메서드 접근 불가
		
		// 슈퍼클래스(Parent) 타입 변수 p3 인스턴스를 서브클래스(Child) 타입 변수 c3 에 전달
//		Child c3 = p3; // 컴파일에러 발생! 명시적 형변환 필수!
		// 형변환 연산자를 사용하여 Parent -> Child 타입으로 형변환 필요함
		Child c3 = (Child)p3; // 명시적 형변환을 통한 다운캐스팅
		// 다운캐스팅에 의해 참조 가능한 영역이 확대됨
		// 따라서, 서브클래스 타입 c3 로 접근 가능한 메서드 : 2개
		c3.parentPrn(); // 상속받은 메서드
		c3.childPrn(); // 상속되지 않은 메서드(서브클래스에서 정의한 메서드)
		
		/*
		 * 다운캐스팅(Down casting) - 결론
		 * - 서브클래스의 레퍼런스가 슈퍼클래스의 인스턴스를 참조하는 것(가리키는 것)
		 *   = 슈퍼클래스의 인스턴스를 서브클래스 타입으로 변환하는 것
		 * - 참조 가능한 영역에 대한 확대 발생
		 * - 자동 형변환이 일어나지 않으므로, 명시적(강제) 형변환이 필수!
		 *   => 즉, 형변환 연산자를 통해 좌변(서브클래스)의 데이터타입을 명시해야한다!
		 * - 명시적 형변환을 통해 문법적(구문) 오류가 해결되더라도
		 *   실제 실행 시점에서 오류가 발생하게 됨
		 *   => 참조 가능 영역의 확대로 인해 존재하지 않는 영역에 대한 참조의 위험성 때문
		 * ------------------------------------------------------------------------------
		 * - 다운캐스팅 후에도 실행 시 예외(오류)가 발생할 수 있으므로
		 *   형변환 전에 인스턴스의 클래스 타입과 참조변수의 상속관계를 고려하여
		 *   명시적 형변환을 수행해야한다!
		 *   
		 * => 최종결론! 
		 *    이전에 이미 업캐스팅 된 레퍼런스를 다시 다운캐스팅 하는 경우에만 안전하다!
		 *    (그 외의 다운캐스팅은 모두 인정되지 않는다!)
		 */
		
	}

}

class Parent {
	public void parentPrn() {
		System.out.println("슈퍼클래스의 parentPrn()");
	}
}

class Child extends Parent {
	public void childPrn() {
		System.out.println("서브클래스의 childPrn()");
	}
}






