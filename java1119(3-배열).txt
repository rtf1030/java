
public class Java1119 {

	public static void main(String[] args) {
		/*
		 * 배열(Array)
		 * - 같은 타입 데이터 여러개를 하나의 변수명을 사용하여 연속된 공간으로 다루는 것
		 * 1. 같은 데이터타입만 하나의 배열로 저장 가능
		 * 2. 기본 데이터타입과 참조 데이터타입 모두 배열로 저장 가능
		 * 3. 배열명(변수명)을 사용하여 여러 데이터 관리 가능
		 * 4. 배열 내에 자동으로 부여되는 번호(인덱스)를 사용하여 배열의 각 요소 접근 가능
		 *    (인덱스 번호는 0부터 시작하여 배열크기-1 번까지 자동으로 부여됨)
		 *    (ex. 배열 크기가 5일 경우 5개의 데이터 저장 가능하며, 인덱스는 0 ~ 4번까지)
		 * 5. 배열 크기는 배열명.length 속성을 통해 얻을 수 있음
		 * 6. 배열은 배열 선언 -> 생성 -> 초기화의 과정을 거쳐서 사용함
		 * 7. 한 번 생성된 배열은 크기 변경이 불가능
		 * 
		 * < 배열 선언 기본 문법 >
		 * 데이터타입[] 변수명; // 데이터타입에 해당하는 배열 타입으로 변수(배열)를 선언
		 * => 스택(Stack) 영역에 배열 공간의 주소를 저장할 참조 변수만 생성됨
		 * => 단, 아직 데이터를 저장할 수 있는 공간은 생성되기 전이므로 데이터 저장 불가!
		 *
		 * < 배열 생성 기본 문법 >
		 * 변수명 = new 데이터타입[배열크기];
		 * => new 연산자에 의해 힙(Heap) 영역에 배열크기만큼의 배열 공간이 생성되고
		 *    해당 배열에 저장되는 데이터타입은 지정된 데이터타입이 사용되며
		 *    생성된 배열 공간의 주소값을 좌변의 변수에 저장
		 * => 배열을 생성하고 나면 자동으로 해당 배열의 공간은 
		 *    지정된 데이터타입의 기본값으로 자동으로 초기화 수행됨
		 *    (ex. int형 기본값 = 0, double형 기본값 = 0.0, String형 기본값 = null 등)
		 * => 또한 생성된 공간은 각각 0 부터 배열크기-1 까지의 인덱스가 자동으로 부여됨
		 * 
		 * < 배열 접근 기본 문법 >
		 * 변수명[인덱스]
		 * => 해당 변수가 가리키는 배열 공간의 지정된 인덱스 번호에 해당하는 요소에 접근
		 * => 변수명은 배열 이름(= 아파트 이름)이고, 인덱스는 배열 요소 위치(아파트 호수)이다.
		 * 
		 * < 배열 초기화 기본 문법 >
		 * 변수명[인덱스] = 데이터;
		 * 
		 * < 배열 선언 및 생성을 하나의 문장으로 결합 >
		 * 데이터타입[] 변수명 = new 데이터타입[배열크기];
		 * 
		 * < 배열 선언, 생성, 초기화를 모두 하나의 문장으로 결합 >
		 * => 배열 생성 시점에서 모든 데이터를 한꺼번에 추가 가능
		 * 데이터타입[] 변수명 = {데이터1, 데이터2, ..., 데이터n};
		 * => 데이터 갯수 n개 만큼의 배열 공간이 자동으로 생성되고, 해당 값으로 초기화 됨
		 *    또한, 생성된 배열은 크기가 고정이므로 차후 더 많은 데이터 저장은 불가능
		 * => 만약, 배열 선언을 먼저 수행한 후 별도로 한꺼번에 초기화하는 경우
		 *    변수명 = new 데이터타입[]{데이터1, 데이터2, ..., 데이터n};
		 *    => 주의! 배열 크기는 지정하지 않도록 해야한다!
		 * 
		 * < 반복문을 사용하여 배열 내의 모든 요소에 차례대로 접근하는 방법 >
		 * for(int i = 0; i < 배열명.length; i++) {
		 * 		// 배열명[i] 형식을 사용하여 배열 요소에 접근 가능
		 * }
		 * => 배열 인덱스가 0번부터 배열크기-1 까지 부여되어 있으므로
		 *    for문을 사용하여 0 부터 배열크기 보다 작을 동안을 제어변수로 지정하여 반복
		 * 
		 */
		
		// 기본 데이터타입 변수를 사용하여 5명의 점수를 저장하는 경우 반복문을 사용하면 코드가 길어진다.

		
		// 배열 선언 : 데이터타입[] 변수명;
//		int score; // 스택(Stack) 공간에 기본데이터타입 int형 변수 score 가 생성됨
		int[] score; 
		// 스택(Stack) 공간에 배열 주소를 저장할 참조데이터타입 변수 score 가 생성됨
		// => 이 때, int 형의 의미는 해당 배열에 저장될 데이터타입이 정수(int)라는 의미
		// 아직 정수형 데이터가 저장될 실제 배열은 생성되기 전이므로 저장 불가
//		score = 10; // 오류 발생! 정수 데이터 저장 불가! 배열 주소만 저장 가능
		
		// 배열 생성 : 변수명 = new 데이터타입[배열크기];
		score = new int[5]; // 정수 데이터 5개 저장 공간이 생성되고 주소값을 score 에 저장
		
		// 배열의 크기 : 배열명.length 속성값을 사용하여 알아내기
		System.out.println("배열 score 의 크기 : " + score.length);
		
		// 배열 접근 : 변수명[인덱스]
		System.out.println("0번 인덱스 요소 : " + score[0]); // 배열 score 의 0번 인덱스 데이터 출력
		System.out.println("1번 인덱스 요소 : " + score[1]); // 배열 score 의 1번 인덱스 데이터 출력
		System.out.println("2번 인덱스 요소 : " + score[2]); // 배열 score 의 2번 인덱스 데이터 출력
		System.out.println("3번 인덱스 요소 : " + score[3]); // 배열 score 의 3번 인덱스 데이터 출력
		System.out.println("4번 인덱스 요소 : " + score[4]); // 배열 score 의 4번 인덱스 데이터 출력
		// 5개 크기를 갖는 배열의 인덱스는 0 ~ 4 까지 존재함
		// 이 때, 4보다 큰 인덱스를 사용할 경우 아래와 같이 오류 발생함
//		System.out.println("5번 인덱스 요소 : " + score[5]); // 배열 score 의 5번 인덱스 데이터 출력
		// => 오류 발생! 오류 메세지는 다음과 같이 출력됨 
		// java.lang.ArrayIndexOutOfBoundsException: 5
		//               at Ex3.main(Ex3.java:67)
		// => 배열 인덱스 범위를 벗어남(원인이 되는 인덱스는 5)
		//    이 오류가 발생한 위치는 Ex3.java 클래스의 67번 라인 코드
		
		// 배열 초기화 : 변수명[인덱스] = 데이터;
		// int score1 = 80, score2 = 100, score3 = 50, score4 = 90, score5 = 77;
		// => 5개의 값을 기본형 변수 대신 배열에 저장(5개의 배열 인덱스 사용)
		score[0] = 80;
		score[1] = 100;
		score[2] = 50;
		score[3] = 90;
		score[4] = 77;
		
		System.out.println("0번 인덱스 요소 : " + score[0]); // 배열 score 의 0번 인덱스 데이터 출력
		System.out.println("1번 인덱스 요소 : " + score[1]); // 배열 score 의 1번 인덱스 데이터 출력
		System.out.println("2번 인덱스 요소 : " + score[2]); // 배열 score 의 2번 인덱스 데이터 출력
		System.out.println("3번 인덱스 요소 : " + score[3]); // 배열 score 의 3번 인덱스 데이터 출력
		System.out.println("4번 인덱스 요소 : " + score[4]); // 배열 score 의 4번 인덱스 데이터 출력
		System.out.println("-------------------------");
		// 반복문을 사용한 배열의 모든 인덱스에 접근
		// for(int i = 0; i < 배열크기; i++) {}
		for(int i = 0; i < 5; i++) { // 0 ~ 4번 인덱스까지 차례대로 접근
			// 배열명[i] 를 사용하여 각 배열 인덱스에 차례대로 접근 가능
			// => 즉, 인덱스 번호를 다른 변수로 대체 가능
			System.out.println(i + "번 인덱스 요소 : " + score[i]);
		}
		// 위의 반복문처럼 사용해도 되지만 배열 크기가 변하면 코드도 변경되어야 함
		// 따라서, 배열의 크기를 동적으로 대응할 수 있도록 작성할 필요가 있음
		// 즉, 조건식 부분에 배열크기를 직접 입력하지 않고 배열명.length 를 지정하면 된다!
		// for(int i = 0; i < 배열명.length; i++) {}
		for(int i = 0; i < score.length; i++) { // 0 ~ 4번 인덱스까지 차례대로 접근
			// 배열명[i] 를 사용하여 각 배열 인덱스에 차례대로 접근 가능
			// => 즉, 인덱스 번호를 다른 변수로 대체 가능
			System.out.println(i + "번 인덱스 요소 : " + score[i]);
		}
		
		System.out.println("-------------------------");
		
		// 배열 선언 및 생성을 동시에 수행
		// 데이터타입[] 변수명 = new 데이터타입[배열크기];
//		int[] arr;
//		arr = new int[10];
		// 위의 두 문장을 한 문장으로 결합
		int[] arr = new int[10];
		arr[0] = 10;
		System.out.println(arr[0]);
	
		// 배열 선언, 생성, 초기화를 동시에 수행
		// 데이터타입[] 변수명 = {데이터1, 데이터2, ..., 데이터n};
		int[] arr2 = {10, 20, 30};
		System.out.println(arr2[0]);
		System.out.println(arr2[1]);
		System.out.println(arr2[2]);
		
		int[] arr3; // 배열 선언만 먼저 수행한 경우
//		arr3 = {10, 20, 30}; // 사용 불가능한 문법
//		arr3 = new int[3] {10, 20, 30}; // 사용 불가능한 문법
		// 배열 생성 문법과 한꺼번에 초기화하는 문법을 결합하여 사용할 때
		// 배열 크기는 데이터의 갯수로 자동 지정되므로 배열 크기 지정을 생략해야함
		arr3 = new int[] {10, 20, 30};
		
		System.out.println("배열 arr3 의 크기 : " + arr3.length);
		
		// for문을 사용하여 arr3 배열 내의 모든 값 출력
		for(int i = 0; i < arr3.length; i++) {
			System.out.println("배열 arr3 의 " + i + "번 인덱스 데이터 : " + arr3[i]);
		}
		
		
	}

}




















